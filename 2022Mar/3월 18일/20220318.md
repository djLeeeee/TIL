# 0318

간만에 새 알고리즘 공부



## 강한 연결 요소 - 코사라주 알고리즘

**직접 짠 코드이니 효율성 검증은 아직이다. 고수 분들 코드 참고할 것!!!**

강한 연결 요소란, 아래의 두 조건을 만족한다.

- 같은 요소 내의 두 노드는 항상 쌍방으로 경로가 존재한다.
- 서로 다른 두 요소의 각 노드 끼리는 쌍방 경로가 존재하지 않는다. 

뭐든 그렇지만, 말로하면 어렵다. 여러 글 읽어봤는데, [자손9319 님의 글](https://jason9319.tistory.com/98) 읽고나서 완전히 이해됐다. 글 읽고 내가 이해한 대로 코드를 짜보았다.  코드에서 각 데이터 다음과 같은 의미를 가진다.  (편의상 부모 &#8594; 자식 노드로 표현, 자식 노드가 부모 노드의 부모가 될 수도 있음)

- node의 수 `n`, edge의 수 `m`
- key 값의 자식 노드를 value로 가지는 `graph`
- value 값의 부모 노드를 value로 가지는 `graph_inv`
- Strongly connected component 를 저장할 `scc`
- 함수 `dfs`의 방문 여부를 체크할 `visited`. 초깃값은 `[False] * (n + 1)`
- 함수 `dfs_inv`의 방문 여부를 체크할 `checked`. 초깃값은 `[False] * (n + 1)`
- `dfs`의 종료 순서대로 저장할 `stack`
- 서로 강하게 연결된 요소들의 `component`. 이후 `scc`에 추가해준다.

작동 순서는 아래와 같다.

1. `dfs(idx)`를 시행한다. 이 때,

   - `visited[idx]`가 True면 그대로 종료한다.

   - 아니라면 방문 체크를 해주고, 인접 노드 `adj`에 대해 `dfs(idx)`을 시행한다. 이 작업이 끝나면 `stack`에 추가해준다.
   ```python 
   def dfs(idx):
       if visited[idx]:
           return
       visited[idx] = True
       for adj in graph[idx]:
           if not visited[adj]:
               dfs(adj)
       stack.append(idx)
   ```

2. `stack`에서 pop을 하면서 그 노드에 대해 `dfs_inv(idx)`를 시행한다. 이 때,

   - `check[idx]`가 True면 그대로 종료한다.

   - `visited[idx]`**가 False면 그대로 종료한다. 이런 점들은 현재 시행에서 component에 추가할 대상이 아니다.**

   - 둘 다 아니라면 `check`에 방문 체크를 해주고, 인접 노드 `adj`에 대해 `dfs_inv(idx)`을 시행한다. 이 작업이 끝나면 `component`에 추가해준다.
   ```python
   def dfs_inv(idx):
       if check[idx] or not visited[idx]:
           return
       check[idx] = True
       for adj in graph_inv[idx]:
           if not check[adj]:
               dfs_inv(adj)
       component.append(idx)
   ```

   이렇게 해주고 나면, `component`에는 하나의 강한 연결 요소가 저장된다!

강한 연결 요소의 조건을 생각해보면, 위의 코드가 이해된다. **어떤 지점에서 역방향 그래프와 정방향 그래프에 대해 DFS 탐색을 했을 때, 탐색 가능한 지점의 교집합은 하나의 강한 연결 요소가 될 것이다.** 정말 이 개념을 충실하게 수행한 알고리즘이라 할 수 있겠다.

암튼 나만의 코사라주 알고리즘 코드를 완성하고, 백준에 제출해봤다.



## Strongly Connected Component - [백준 2150](https://www.acmicpc.net/problem/2150)

코사라주

```python
from sys import stdin, setrecursionlimit
from collections import defaultdict

input = stdin.readline
setrecursionlimit(10 ** 5)


def dfs(idx):
    if visited[idx]:
        return
    visited[idx] = True
    for adj in graph[idx]:
        if not visited[adj]:
            dfs(adj)
    stack.append(idx)


def dfs_inv(idx):
    if check[idx] or not visited[idx]:
        return
    check[idx] = True
    for adj in graph_inv[idx]:
        if not check[adj]:
            dfs_inv(adj)
    component.append(idx)


n, m = map(int, input().split())
graph = defaultdict(list)
graph_inv = defaultdict(list)
for _ in range(m):
    x, y = map(int, input().split())
    graph[x].append(y)
    graph_inv[y].append(x)
scc = []
visited = [False] * (n + 1)
for i in range(1, n + 1):
    stack = []
    if not visited[i]:
        dfs(i)
        check = [False] * (n + 1)
        while stack:
            component = []
            now = stack.pop()
            if not check[now]:
                dfs_inv(now)
                if component:
                    component.sort()
                    scc.append(component)
scc.sort()
print(len(scc))
for c in scc:
    print(*c, -1)
```

1트만에 통과! 다행히 코사라주 알고리즘을 잘 이해한 듯 하다.

처음에는 for문으로 `dfs`를 시행하는 부분이 아래와 같았다.

```python
for i in range(1, n + 1):
    stack = []
    dfs(i)
    ...
```

통과를 하긴 했지만, 소요 시간 0.5초로, 썩 만족스럽지 못했다. 그래서 현재 코드와 같이

```python
for i in range(1, n + 1):
    stack = []
    if not visited[i]:
        dfs(i)
        ...
```

함수 시행 여부를 체크해줬더니 0.3초로 확 줄어들었다. `dfs(idx)`는 만약 idx를 이미 방문했다면 바로 종료되므로 그냥 처음 코드처럼 짜도 될 거라 생각했는데, 함수 호출하는 것 자체가 시간을 꽤 잡아먹는지도 모르겠다. 다음부턴 주의하자.

 