# 0717

내일 대면 수업이다. 후....

면접 본 곳에서 아직 연락을 안 준다. 떨어졌나보다 흑흑

이럴 땐 뭐다? 알고리즘으로 기분 전환을 하자~ 오늘도 틀렸던 문제 위주로 가자!



## 카드 게임과 쿼리 - [백준 24517](https://www.acmicpc.net/problem/24517)

게임 이론

```python
from sys import stdin

input = stdin.readline


def f(i, j):
    if i <= 0:
        dp[i][j] = 0
        return 0
    if dp[i][j] > -1:
        return dp[i][j]
    result = 1
    for bit in range(10):
        if (1 << bit) & j:
            result &= f(i - bit - 1, j - (1 << bit))
    dp[i][j] = result ^ 1
    return dp[i][j]


dp = [[-1] * 1024 for _ in range(65)]
rs = {0: 0}
ans = ''
for _ in range(int(input())):
    a, b, k = map(int, input().split())
    s = (k * k + k) // 2
    x, y = (b - a) // s, (b - a) % s
    if k % 2 and x % 2:
        if not f(y, (1 << k) - 1):
            ans += 'swoon\n'
        else:
            ans += 'raararaara\n'
    else:
        if f(y, (1 << k) - 1):
            ans += 'swoon\n'
        else:
            ans += 'raararaara\n'
print(ans.rstrip())
```

예엣날에 알고리즘 처음 했던 시절? 겁도 없이 플레 문제에 덤비던 시절이 있었다. 그 때가 그립긴 한데... 암튼 그 때 신촌 대회였나? 오픈 컨테스트에서 풀고 틀렸던 문제이다.

오늘 다시 보니, 스프라그 그런디 정리로 풀 수 있을 거 같아 쭉 그런디 수를 적어보니, n + 1의 배수일 때만 그런디 수가 0이었다... 하지만 WA.

천천히 생각했더니, 단순하게 그런디 수를 계산할 수 있는 문제가 아니었다. **카드를 (한 사이클에서) 중복 사용할 수 없기 때문**에, 자신의 턴에 뽑고 싶은 카드가 없을 수도 있다. 그렇게 다시 고민하다가, `k`의 범위가 10 이하라는 게 눈에 들어왔다. 그런디 수로 푸는 거라면 이렇게 작을 필요가 없을 것이고, 10~20 정도의 스케일이면 합리적 의심이 가능한 풀이가 있다. 아마도 2<sup>k</sup> 스케일의 풀이가 정답이라는 뜻. 그럼 2<sup>k</sup>를 어디다 쓸 수 있는 지 생각해보면... 비트 연산이지 뭐

남은 수를 `i`, 남은 숫자 카드의 비트 표시를 `j`라 하자. 그 다음 `f(i, j)`를 지금 턴에서 이길 수 있으면 1을, 지면 0을 반환하도록 하자. 그러면,

- `i`가 0 이하면 졌다
- `j`와 비트 체크를 해서 `b`번째 비트가 체크되어 있다 해보자. 그러면, `f(i - b, j - 2<sup>b</sup>)`는 현재 상황에서 `b`를 고른 것을 의미한다. 그러면, 고를 수 있는 숫자를 모두 골라보고 얻은 각각의 `f`가 모두 1이라면, 이 플레이어는 패배한 것이다. 왜냐? 지금 어떤 수를 골라도 다음 플레이어에게 승리 플랜이 존재하는 거니까.
- 이외의 상황이라면 승리 플랜이 존재한다.

이제 구현만 해주면 된다! 당연하지만, 한 사이클에서 얻을 수 있는 합이 정해져 있고 그 사이클에 소모되는 턴이 정해져 있으니 적당히 가공해 주,면 AC.

이제 틀린 문제가 32문제 남았다. 20대까지 해보자!
