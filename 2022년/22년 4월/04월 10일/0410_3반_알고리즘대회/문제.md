## :page_with_curl: 규칙

- 진행 시간은 총 2시간입니다. 
- **진행 시간 중 다른 사람과 문제에 관해 토론은 금지입니다. 이외의 모든 행동은 자유입니다. (ex. 조기 퇴실, 인터넷 검색, 재제출 등...)**
- 파이썬으로 문제 풀이를 진행하시길 권장드리며, 파이썬 내의 모든 라이브러리는 사용 가능합니다.
- **악랄한 A형처럼 숨겨놓은 테스트 케이스가 없습니다!** 문제 별 각각 주어진 `input_문제번호.txt`에 대해 실행했을 때, `output_문제번호.txt`와 정확히 일치하면 만점을 받습니다. 다만, 계산하지 않고 답만 출력하는 코드는 당연히 0점입니다.
- **모든 테스트 케이스를 맞추지 못하였더라도, 맞춘 테스트 케이스의 수에 비례하여 부분점수를 얻을 수 있습니다.**
- **런타임 에러가 발생한 경우에, 런타임 에러가 발생하기 전까지 출력한 결과에 대해서만 채점을 진행합니다.**
- 문제에서 별도의 언급이 없는 경우, 코드 실행 시간에 제한은 없습니다.
- 전체 합산 점수는 100점을 넘을 수 없습니다. (가산점은 100점을 받지 못한 경우에만 가져갑니다)
- 순위는 전체 합산 점수가 높은 순으로 매깁니다.
- 제출은 4시 5분까지 가능합니다. 디스코드 개인 메세지로 어떤 형태로든 정답 코드를 제출해주시면 됩니다. 이외의 별도 제출 양식은 없습니다.





## :one: 동전(20점) - Subtask: 숏코딩(가산점 5점)

> **모든 테스트 케이스를 맞춘 정답 코드 중, 코드의 길이가 가장 짧은 코드를 제출한 사람에게 가산점 5점이 주어집니다! ** 코드 길이는 제출한 파이썬 파일의 바이트 단위 크기를 의미합니다. 



#### :closed_book: Input 형식

첫 줄에 전체 테스트 케이스 개수 `t` 가 주어진다.
- 각 테스트 케이스 별로 첫 줄엔 동전 종류 `n`과 목표 금액 `m`원이 공백으로 구분되어 주어진다.
- 둘째 줄에 `n`개의 동전의 가치가 공백으로 구분되어 주어진다. 각 동전의 가치는 다르다.
- 항상 정확히 지불 가능한 경우만 주어진다.
- 각 종류의 동전은 무한히 많이 가지고 있다.



#### :book: Output 형식

필요한 동전의 최소 개수를 테스트 케이스 번호와 함께 한 줄에 출력한다.



#### :page_with_curl: 예시

###### Input

```
3
5 400
1 5 10 50 100
3 470
10 100 50
1 1000
10
```

###### Output

```
#1 4
#2 7
#3 100
```





## :two: 타워 디펜스 게임(40점) - Subtask: 가지 치기

> **SWEA가 좋아하는 완전 탐색 문제입니다. 가지 치기를 하지 않을 경우, 코드 실행 시간이 3초를 넘어갈 확률이 높습니다. 3초 안에 출력한 결과값에 대해서만 정답으로 인정됩니다.**
>
> 해당 문제는 별도의 가산점이 없습니다. 대신 테스트 케이스가 많은 종류의 edge 케이스가 들어있습니다!



n * m 크기의 격자판에서 타워 디펜스 게임을 하려고 한다. 타워는 총 4가지 조합으로 대포를 발사할 수 있다.

1. (타워 기준) 왼쪽과 위쪽으로 발사 - `1`번 방향
2. 오른쪽과 위쪽으로 발사 - `2`번 방향
3. 오른쪽과 아래쪽으로 발사 - `3`번 방향
4. 아래쪽과 왼쪽으로 발사 - `4`번 방향

대포를 발사하면 대포알은 일직선으로 날아가면서 경로 상의 적을 물리친다.

**각 타워의 대포들을 적절히 배치하여, 동시에 발사하여 격자판 위의 적들을 모두 물리치려고 한다.**

격자판에는 총 4가지 종류의 문자가 주어진다.

1. 1 ~ 9 사이의 숫자 `i` : `i`번 타워. 
2. `.`  : 해당 구역에 아무 것도 없음. 대포알의 진행에 아무 영향도 끼치지 않는다.
3. `#` : 벽. 대포알의 진행을 가로막는다.
4. `@` : 적

... 이대로 적을 물리칠 수 있도록 대포를 배치하고 싶지만 몇 가지 제약 사항이 존재한다.

1. 타워는 몹시 연약하다! **타워에서 발사한 대포알이 다른 타워에 맞으면 안 된다.**
2. 벽은 몹시 튼튼하다! **벽에 부딪힌 대포알은 더 이상 진행하지 않고 그대로 사라진다.**
3. 대포알은 서로 부딪히지 않고 진행한다.
4. 격자판 밖으로 나간 대포알은 그대로 사라진다.

대포를 어떻게 배치해야 모든 적을 물리칠 수 있을지 구해보자!



#### :closed_book: Input 형식

첫 번째 줄에 테스트 케이스의 갯수 `t`가 주어진다

- 각 테스트 케이스의 첫 줄에는 격자판의 세로 길이 `n`과 가로 길이 `m`, 그리고 타워의 갯수 `k`가 주어진다.
- 이후 `n`개의 줄에 격자판의 상태가 주어진다. 격자판 위의 숫자는 타워의 번호를, `.`은 빈 공간을, `#`은 벽을, `@`는 적을 나타낸다.
- `n`, `m` , `k`는 9보다 작거나 같은 자연수이다.
- 격자판 위에는 항상 1, ..., `k`가 각각 하나씩 주어진다.
- 항상 정답이 존재하는 경우가 주어진다.
- 적이 처음부터 존재하지 않을 수도 있다.



#### :book: Output 형식

각 테스트 케이스의 번호와 함께, 1번 타워부터 `k`번 타워까지 차례대로 어떻게 대포를 조합하여 발사해야 하는지 공백으로 구분하여 출력한다.

답이 여러 가지인 경우, 그 중 하나를 출력한다.



#### :page_with_curl: 예시

###### Input

```
3
3 3 1
.@.
.1@
###
3 5 2
@....
1@#@2
....@
5 5 3
....#
.@@1.
...@2
##@3.
.....
```

###### Output

```
#1 2
#2 2 4
#3 1 1 4
```

1번 테스트 케이스에서는 1번 타워에서 위와 오른쪽으로 대포를 발사(2번 조합)해야 한다. 따라서 답은 `2` 가 된다.

2번 테스트 케이스에서는 1번 타워는 2번 조합, 2번 타워는 4번 조합으로 발사해야 한다. 타워 사이에 벽이 있기 때문에 해당 방법으로 발사해도 타워에 피해가 생기지 않는다. 따라서 답은 `2 4`가 된다.

3번 테스트 케이스에서는 1번 타워는 1번 조합, 2번 타워는 1번 또는 4번 조합, 3번 타워는 4번 조합으로 발사해야 모든 적을 물리치면서 타워가 무너지지 않는다. 따라서 답은 `1 1 4` 또는 `1 4 4 `가 된다. 





## :three: 길 막기(40점) - Subtask: 다익스트라(가산점 10점)

> **3번 문제는 완전 탐색으로 해결 가능하도록 설계되었습니다.**
>
> **다익스트라 한 번으로 답을 구하는 풀이도 존재합니다. 다익스트라를 사용해 절반 이상의 테스트 케이스에서 정답을 얻어낸 경우, 추가 점수 10점을 받습니다. 완전 탐색 / 백트래킹 기법이 아닌, 다른 실행 시간이 짧은 참신한 풀이로 푼 경우에도 가산점을 받을 수 있습니다. **



n * m 크기의 격자판에 각 격자마다 번호가 주어져있다.

조건에 맞게 구역을 구매해 해당 구역들에 벽을 세워 격자판 맨 윗줄에서 제일 아랫줄로 가는 **길을 막으려 한다**. 

- 어느 번호의 구역을 구매한다면 해당 번호를 가진 구역을 모두 구매해야 한다.

길을 막기 위해 최소로 구매해야 할 구역의 크기를 구하자. **윗줄의 모든 지점에서 각각 출발해 상하좌우로 이동하여 아랫줄의 어떤 지점으로도 갈 수 없을 때, 길이 막혔다고 정의한다.**



#### :closed_book: Input 형식

첫 줄에 전체 테스트 케이스의 수 `t`가 주어진다. 

- 각 테스트 케이스 첫 줄에 구역의 세로 길이 `n`, 가로 길이 `m`, 구역 종류의 개수 `k`가 공백으로 구분되어 주어진다. (3 <= `n`, `m` <= 10, 0 < `k` < 10)
- 이후 n개의 줄에 각 구역의 번호 `x` (0 < `x` <= `k`)가 주어진다. 첫 줄과 마지막 줄은 시작 지역과 도착 지역으로, 항상 0으로 주어진다.
- `k`는 10보다 작은 자연수이며, 같은 번호의 구역들은 모두 서로 이어져 있다.
- 모든 `k`보다 작거나 같은 번호를 가진 구역은 반드시 존재한다.



#### :book: Output 형식

길을 막기 위해 구매해야 하는 땅의 최소 크기를 테스트 케이스 번호와 함께 출력한다.



#### :page_with_curl: 예시

###### Input

```
1
8 8 9
0 0 0 0 0 0 0 0
1 1 2 2 6 7 7 7
1 1 2 2 6 8 8 8
2 1 2 2 5 8 8 8
2 2 2 2 5 9 9 8
3 2 4 4 5 9 9 9
3 4 4 5 5 9 9 9
0 0 0 0 0 0 0 0
```

###### Output

```
#1 16
```



예시의 1번 테스트 케이스를 나타내면 아래와 같다.

![image](https://user-images.githubusercontent.com/97663863/161238928-38f699a0-ff9c-485b-a044-3f0074ef3dab.png)

아래와 같이 3, 4, 5, 6, 7번 땅을 구매하면 길을 막을 수 있다. 아래 방법보다 땅을 적게 구매하는 방법은 없다.

![image](https://user-images.githubusercontent.com/97663863/161239348-2c41fe38-1dbc-4788-a77d-b15d9daaed1b.png)
