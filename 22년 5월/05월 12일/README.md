# 0512



## :diamond_shape_with_a_dot_inside: 바둑 - [백준 9495](https://www.acmicpc.net/problem/9495)

이분 매칭

```python
from sys import stdin

input = stdin.readline


def dfs(idx):
    for adj in graph[idx]:
        if visited[adj]:
            continue
        visited[adj] = True
        if not match[adj] or dfs(match[adj]):
            match[adj] = idx
            return 1
    return 0


n = int(input())
board = [list(input().strip()) for _ in range(n)]
blank = 0
for i in range(n):
    for j in range(n):
        if board[i][j] == '.':
            blank += 1
            board[i][j] = blank
graph = [[] for _ in range(blank + 1)]
white = 0
di = [1, -1, 0, 0]
dj = [0, 0, 1, -1]
for i in range(n):
    for j in range(n):
        if board[i][j] == 'o':
            white += 1
            for d in range(4):
                ni = i + di[d]
                nj = j + dj[d]
                if 0 <= ni < n and 0 <= nj < n and type(board[ni][nj]) == int:
                    graph[board[ni][nj]].append(white)
ans = white + blank
match = [0] * (white + 1)
for i in range(1, blank + 1):
    visited = [False] * (white + 1)
    ans -= dfs(i)
print(ans)
```

이미 검은 돌이 놓여져 있는 공간은 어떤 방법으로도 빈 칸으로 만들 수 없다. 그렇다면 비었거나 흰색 돌이 놓인 칸이 최종 상태에서 비어있을 수 있는 포텐셜을 갖고 있다. 이제, 두 개의 이웃한 돌이 어떤 상태가 가능한지 살펴보자. 편의상, 어떤 상황에서 빈 칸 개수를 그 상황의 점수라고 정의하자.  

- **[검은돌] - [무언가]** : 해당 칸에 검은 돌을 놓아 (두 칸에서 얻는) 점수를 늘릴 방법이 존재하지 않는다.
- **[흰돌] - [흰돌]** : 문제에서 해당 상황은 주어지지 않는다.
- **[빈칸] - [빈칸]** :  해당 칸에 조작을 가할 이유는 없다. **(검은 돌을 놓을 필요가 없다는 의미가 아니다. 점수의 포텐셜을 생각했을 때 해당 칸에서 얻는 2점을 뺏어갈 이유가 없다는 뜻이다.)**
- **[흰돌] - [빈칸]** : 제일 중요한 관계이다. 주변 상황에 따라서, 빈 칸에 검은 돌을 놓고 흰 돌이 있는 칸을 빈 칸으로 바꿀 수 있다. 주목할 점은, **두 칸에서 얻은 점수는 변하지 않았다.** 바꿔 말하면, 두 칸 중 한 칸에서 점수를 얻을 수 있다.

이제부터 문제 풀이 과정이 재밌어진다. 한 쪽은 흰 돌의 집합, 다른 한 쪽은 빈 칸의 집합을 놓고, 흰 돌과 빈 칸이 서로 붙어있을 때 간선을 그려 이분 그래프 `G`를 만들자. 간선의 의미는 위에서 살펴봤듯이 간선의 양 끝 중 한 점에서 점수를 얻을 수 있다는 의미이다. 이제 슬슬 이분 매칭의 냄새가 나기 시작한다. **`G` 의 최소 버텍스 커버를 생각해보자. 이게 어떤 의미를 가지는가 생각해보면, 해당 칸에서는 점수를 얻지 않겠다라는 의미이다.**

증명해보자. 4가지 경우를 모두 살펴보면 된다.

1. **빈 칸이 커버에 포함된 경우**

   해당 칸에 검은 돌을 놓는다.

2. **빈 칸이 커버에 포함되지 않은 경우**

   해당 칸은 그대로 둔다. 그대로 해당 칸에서 점수를 얻는다.

3. **흰 돌이 커버에 포함된 경우**

   주변 빈 칸들이 커버에 포함되지 않았다. 즉, 흰 돌이 그대로 있다.

4. **흰 돌이 커버에 포함되지 않은 경우**

   주변 빈 칸들에 모두 검은 돌이 들어와야 한다. 그게 버텍스 커버의 정의이니까. 그렇게 되면 흰 돌이 빈 칸으로 바뀌며 점수를 얻는다.

진짜 이분 매칭으로 풀려버렸다. 우리는 전체 정점의 개수에서 최소 버텍스 커버, 즉 최대 매칭의 개수를 빼주면 답을 얻을 수 있다.

예~~~엣날에 이분 매칭에 한참 꽂혔을 때, 다이아 이분 매칭 문제도 풀어봐도 되겠는데? 싶어서 도전했던 문제로 기억한다. 그걸 이제야 풀었다. 사실 이분 매칭 문제라는 사실을 이미 알고 있어 풀 수 있었다. 그래도 이분 매칭으로 해결할 수 있다는 걸 증명하고 풀어서 조금 뿌듯하다 ㅎㅎ