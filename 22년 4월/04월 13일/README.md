# 0413



## Django project

날짜와 약속, 약속과 참여 인원을 각각 1대 N 구조로 코드를 싹 다 뜯어고치자! 고 팀원들에게 제안했지만, 기존 방법에서도 약속의 개수를 출력할 방법이 있어 각하.

```django
{% for date, value in plan_cnt.items %}
  <h2 class="date_font">{{ date }} {{ value }}</h2>
{% endfor %}
```

`plan_cnt`라는 딕셔너리를 만들어줘서 넘겨줬고, `items`를 사용해 `key`와 `value`를 각각 출력해줬다. 주의할 점은, 

1. `items()`가 아니라 `items`다.
2. `defaultdict`으로 넘기게 되면, 출력할 때 나오는 `class 'int'`라는 글씨까지 `items`를 적용하면서 오류가 생긴다. 

알고리즘 풀 때 애용하는 `defaultdict`을 사용하면 `plan_cnt`를 쉽게 구현할 수 있을 거 같아 적용해봤는데, 2번 같은 말도 안 되는 오류가 발생했다. 데이터를 넘겨줄 때 딕셔너리 자체를 넘겨주는 것이 아닌, print할 때 나오는 string 형태로 전달하는 것 같다. 내부 코드를 좀 더 뜯어봐야 확인 가능할 듯.



## 도로 정보 - [백준 24548](https://www.acmicpc.net/problem/24548)

구현? 카테고리가 마땅치 않다..

```python
from sys import stdin
from collections import defaultdict

input = stdin.readline

n = int(input())
road = input().strip()
trans = {'T': 0, 'F': 1, 'G': 2, 'P': 3}
state = defaultdict(int)
state[(0, 0, 0, 0)] = 1
ans = 0
cnt = [0, 0, 0, 0]
for i in range(n):
    cnt[trans[road[i]]] += 1
    cnt[trans[road[i]]] %= 3
    now = tuple(cnt)
    ans += state[now]
    state[now] += 1
print(ans)
```

틀린 문제 없애기 project를 시작했다. 만만한 골드부터 해치우자.

이전 대회에서 풀었다가 틀린 문제다. 가장 쉬운 풀이는 `O(n^2)`이겠지만, `O(n)`으로 처리해야 한다. 별로 어려운 게 아닌데... 왜 생각을 못 했나 모르겠다. 각 state가 같은 지점을 양 끝으로 하는 구간이 흥미로운 구간이 된다는 것이 핵심.



## 프로그래머스 스킬 체크

#### Level 1

쓸 말 없다. 프로젝트 끝나고 떠들고 놀면서 5분 컷.

#### Level 2

10분 컷. query 조작 문제가 조금 귀찮았지만 딱 그 정도?

#### Level 3

이미 풀어본 카카오 기출 문제를 그대로 내시면... 어쩌자는 겁니까... 풀이 방법 이미 알아서 20분 정도 소요.

#### Level 4

이제야 좀 푸는 맛이 난다.

1번은 행렬 곱셈 순서 정해서 연산량을 최소로 하는 문제. 근데 백준에서 이미 해봤죠? DP 로 해결 가능.

2번은 트리 그래프에서 `u`, `v`, `w` 서로 다른 세 점을 뽑고, 세 거리 중 중간값을 최대로 하는 문제였다. 드디어 처음 보는 유형이다. 내가 세운 문제 풀이 가설은 아래와 같았다.

> 두 점은 반드시 트리의 지름이다. 
>
> 그 두 점과 떨어진 거리 중 더 큰 값이 최대인 점을 찾으면 우리가 찾는 세 점이다. 

트리 그래프를 그려서 트리의 지름이 여러 개 있는 경우를 생각해봤다. 서로 다른 2개의 트리의 지름에 대해 2가지 상태가 있을 수 있었다.

1. vertex 하나만 공유하는 경우 - 사실 이 경우는 2번 케이스에서 edge를 0개 공유하는 경우로 치환 가능.
2. edge 몇 개를 공유하는 경우 - tree 구조이기 때문에 cycle이 없고, 공유하는 edge들 만으로 subgraph를 취하면 그 subgraph는 connected graph이다.

그 다음 내가 정한 트리의 지름 `u`, `v`가 정답에 속하지 않는다고 가정을 해봤는데, 그림을 그려보니 1번과 2번 경우에서 항상 속함을 쉽게 증명할 수 있었다.

이제 문제만 풀어주면 된다. 예전에 트리의 지름을 찾는 백준 문제 기억난다. 시작점 임의로 잡고 최대 거리 점을 뽑아주고, 그 점에서 또 최대 거리인 점을 찾아주면 트리의 지름 찾기 완료!

30분 정도 소요됐다.

#### Level 5

새벽 2시에 풀기 시작했는데, 갑자기 미친듯이 졸음이 쏟아져 왔다.

애초에 2시간 30분 짜리 시험을 새벽 2시에 열어본 놈이 정신 나간 놈이긴 한데... 암튼 내일 수업을 위해 그만하는 걸로. 내일이나 모레에 맨 정신으로 하면 좋을 듯.